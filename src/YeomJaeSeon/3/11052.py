# 민규는 무조건 돈을 많이 지불하고싶음


N = int(input())

p = list(map(int, input().split()))

d = [-1] * (N + 1) #  dp테이블 -1로 초기화. 근데 의미없음. 0으로초기화해도됨.
# 왜냐면 1개가 들어있는 팩1을 통해 dp테이블이 최초에 무조건 다 초기화된다.

d[0] = 0 # 카드 0개사려면 0원지불. 

for i in range(N):
  for j in range(i + 1, N + 1):
    d[j] = max(d[j - (i + 1)] + p[i], d[j])  

print(d[N])

# 로직
# p = [1, 5, 6, 7] 일때(팩 가격)
# i개를 구매할때 d[i](그 당시의 최대금액) 과 d[i - 팩의 가격] + 팩의 가격의 최대값을 구하면됨
# i가 0부터 N - 1까지 p[i]를 순서대로 하나씩 사용하며 dp테이블을 갱신하는게 관건. p[0]만사용한 dp테이블 -> p[1]을 추가로 사용한 dp테이블 갱신 -> p[2]를 추가로 사용한 dp 테이블 갱신...
# 자세한 예시

# 최초
# d = [0, -1, -1, -1, -1]

# p[0]만 사용할 경우 - 1 (카드 하나든 팩1의 가격)
# d = [0, 1, 2, 3, 4] (j = 1이라면 그당시의 최대금액 -1과 d[1 - 1] + p[0] 의최대값을 구하면 1이됨.)

# p[1]사용 추가 - 5(카드 두개든 팩2의 가격)
# d = [0, 1, 5, 6, 10] (j = 2일 때, 그당시의 최대금액 2와 d[2 - 2] + p[1]중 최대값은 5가됨)

# p[2]사용 추가 - 6원(카드 세개든 팩3의 가격)
# d = [0, 1, 5, 6, 10] ( j = 4일경우 그당시최대금액 10과 d[4 - 3] + p[2]의 최대값은 기존의 10원임 )

# p[3]사용할 경우 dp테이블도 똑같이 갱신
